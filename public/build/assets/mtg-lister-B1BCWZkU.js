function h(o){return new Promise((d,u)=>{o.onsuccess=e=>{d(e.target.result)},o.onerror=e=>{console.error(e),u(e.target.error||e)}})}async function p(o,d,u){const e=await new Promise(r=>{const t=window.indexedDB.open(o,d);t.onsuccess=a=>{r(a.target.result)},t.onupgradeneeded=a=>{const s=a.target.result;s.onerror=n=>{var c;console.error((c=n.target.error)==null?void 0:c.message)},u(s)}});return e.onerror=r=>{var t;console.error((t=r.target.error)==null?void 0:t.message)},e}function f(o){const{set:d,num:u}=o;return`${d} ${u}`}function g(o){const{set:d,num:u}=o;return{set:d,num:u}}function y(){const o=p("mtg-lister",1,t=>{t.createObjectStore("cards",{keyPath:"setNum"}),t.createObjectStore("cardList",{autoIncrement:!0}).createIndex("listName","listName",{unique:!1}),t.createObjectStore("options",{keyPath:"name"})}),d={async save(t){await this.saveAll([t])},async saveAll(t){t.forEach(s=>{s.setNum=s.setNum||f(s),s.savedAt=Date.now()});const a=(await o).transaction(["cards"],"readwrite").objectStore("cards");for(let s=0;s<t.length;s++)try{await a.put(t[s])}catch(n){console.log("Error storing card to DB",{card:t[s],cards:t}),console.error(n)}},async get(t){try{return h((await o).transaction(["cards"]).objectStore("cards").get(f(t)))}catch{return null}},async getList(t){const a=Object.keys(t.map(i=>f(i)).reduce((i,l)=>(i[l]=null,i),{})),s=[],n=(await o).transaction(["cards"]).objectStore("cards");let c;for(let i=0;i<t.length;i++)try{c=await h(n.get(a[i])),c?s.push(c):console.log("card not found",a[i])}catch(l){console.log("Error retrieving card "+a[i]),console.error(l)}return s}};function u(t){var i;const{key:a=null,listName:s=null,search:n=null,foil:c=!1}=t;return{key:a||void 0,listName:s===null?void 0:s,search:n?{q:n.q,results:(i=n.results)==null?void 0:i.map(g)}:void 0,card:t.card?g(t.card):null,foil:c}}return{cards:d,lists:{async getLists(){const t=await o,a=[];return await new Promise(s=>{const c=t.transaction(["cardList"]).objectStore("cardList").index("listName");c.openKeyCursor(null,"nextunique").onsuccess=i=>{const l=i.target.result;l?(a.push(l.key),l.continue()):s()}}),a},async getList(t=""){return h((await o).transaction(["cardList"]).objectStore("cardList").getAll())},async addRow(t,a=""){try{t=u(t),t.listName=a;const s=(await o).transaction(["cardList"],"readwrite").objectStore("cardList");return t.key=await h(s.add(t)),await h(s.put(t,t.key)),t}catch(s){console.log("Error adding row"),console.error(s)}},async updateRow(t){try{t=u(t);const a=(await o).transaction(["cardList"],"readwrite").objectStore("cardList");await h(a.put(t,t.key))}catch(a){console.log("error updating row"),console.error(a)}},async removeRow(t){console.error("removing row",t),await h((await o).transaction(["cardList"],"readwrite").objectStore("cardList").delete(t))},async clearList(t=""){const a=await o;return new Promise(s=>{const c=a.transaction(["cardList"],"readwrite").objectStore("cardList").index("listName");c.openCursor(IDBKeyRange.only(t)).onsuccess=i=>{const l=i.target.result;l?(l.delete(),l.continue()):s()}})}},options:{async get(t,a=null){const s=await h((await o).transaction(["options"]).objectStore("options").get(t));return(s==null?void 0:s.value)||a},async set(t,a){await h((await o).transaction(["options"],"readwrite").objectStore("options").put({name:t,value:a}))}}}}function C(){const o=y(),d=Alpine.reactive({}),u={get(s){return d[f(s)]||null},set(s){return o.cards.save(this.remember(s))},setList(s){return s.forEach(n=>this.remember(n)),o.cards.saveAll(s)},remember(s){return s&&(d[f(s)]=s),s},async recall(s){let n=this.get(s);return n||(n=await o.cards.get(s),n&&console.info("card recalled",n),this.remember(n))},async recallList(s){(await o.cards.getList(s.filter(c=>!this.get(c)))).forEach(c=>this.remember(c))}};async function e(){return o.lists.getLists()}function r(s){const{set:n,num:c}=s;return{set:n,num:c,get card(){return u.get(s)}}}function t(s){var n;return{...s,search:s.search?{q:s.search.q,results:(n=s.search.results)==null?void 0:n.map(r)}:void 0,card:s.card?r(s.card):null,error:null,get hasError(){return!!this.error}}}function a(s){return{rows:[],async add(n){const c=await o.lists.addRow(n,s),i=t(c),l=this.rows.push(i);return this.rows[l-1]},async remove(n){return this.rows.splice(this.rows.indexOf(n),1),this.removeRowRecord(n)},async removeRowRecord(n){return o.lists.removeRow(n.key)},async clear(){this.rows=[],await o.lists.clearList(s)},async update(n){await o.lists.updateRow(n)},get byNew(){return this.rows.toReversed()},async populate(){const c=(await o.lists.getList(s)).map(l=>t(l));this.rows.push(...c);const i={};c.forEach(l=>{var m;l.card?i[f(l.card)]=l.card:(m=l.search)!=null&&m.results&&l.search.results.forEach(w=>{i[f(w)]=w})}),await u.recallList(Object.values(i))}}}return{cards:u,cardPop:r,getLists:e,list:a}}document.addEventListener("alpine:init",()=>{const o=()=>(e=>e[Math.floor(Math.random()*e.length)])(["eld 299","fdn 128","snc 425","woe 287","ncc 13"]),d=C(),u=kat.rateLimitedService("https://api.scryfall.com/",100);Alpine.data("mtgLister",()=>({search:"",cardData:d.cards,isFoil:!1,list:d.list(""),lists:[],placeholder:o(),preview:null,select:null,hasSetsData:!!mtgSets.length,rowActionIndex:0,setCodeLock:null,async init(){this.lists=await d.getLists(),await this.list.populate()},get actionRow(){return this.list.byNew[this.rowActionIndex]||null},get actionRowKey(){var e;return(e=this.actionRow)==null?void 0:e.key},get setCodeHint(){var e;if(this.action.usePrev){if(this.action.do==="+")return this.action.match.card.set.toUpperCase();if(this.action.do==="l+")return this.action.setCode.toUpperCase()}return(e=this.setCodeLock)==null?void 0:e.toUpperCase()},setByCode(e){if(this.hasSetsData)try{return mtgSets.find(r=>r.code===e.toLowerCase())||null}catch(r){return console.error(e,r),null}return null},get lockedSetPlaceholder(){return this.setCodeLock?String(Math.floor(Math.random()*this.lockedSet.card_count)+1):this.placeholder},get lockedSet(){return this.setCodeLock?this.setByCode(this.setCodeLock):null},setName(e){const r=this.setByCode(e);return r?r.name:e.toUpperCase()},get resolvedCards(){return this.list.rows.filter(r=>{var t;return(t=r.card)==null?void 0:t.card})},get distinctCards(){const e=this.resolvedCards,r={},t=[];return e.forEach(a=>{const s=`${a.card.set}:${a.card.num}:${a.foil?"foil":"-"}`;r[s]!==void 0?t[r[s]].count++:(r[s]=t.length,t.push({count:1,name:a.card.card.name,set:a.card.set,num:a.card.num,foil:a.foil}))}),t},get csvDownload(){return encodeURI(`data:text/csv;charset=utf-8,Count,Name,Edition,Collector Number,Foil\r
`+this.distinctCards.map(e=>[e.count,`"${e.name.replace('"','""')}"`,e.set,e.num,e.foil?"foil":""].join(",")).join(`\r
`))},get csvFileName(){const e=this.resolvedCards.length;if(!e)return"mtg-list_empty.csv";const r=this.distinctCards[0].name.replace(/[^a-z0-9]/gi,"_").toLowerCase();return`mtg-list_${e}_${r}.csv`},matchCardRef(e){var c,i;if(!this.hasSetsData)return null;const r=e.split(" ");if(r.length===1&&this.setCodeLock&&r.unshift(this.setCodeLock),r.length!==2)return null;const t=r[0]==="<";if(t)if((c=this.actionRow)!=null&&c.set)r[0]=this.actionRow.set;else return null;const a=this.setByCode(r[0]==="<"&&((i=this.actionRow)!=null&&i.set)?this.actionRow.set:r[0]);if(!a)return null;const s=r[1].match(/(?<number>\d{1,4})(?<foil>f?)/i);if(!s)return null;const n=Number(s.groups.number);return n>a.card_count?null:{card:{set:a.code,num:n},foil:!!s.groups.foil,usePrev:t}},get action(){var s,n;const e=this.actionRow,r=(s=e==null?void 0:e.card)==null?void 0:s.card,t=this.search.trim().toLowerCase();if(!t)return r||(n=e==null?void 0:e.search)!=null&&n.results?{do:"++",row:e}:{do:null};if(t.length===1)switch(t){case"v":if(e)return{do:r?"vC":"vR",row:e};break;case"f":if(r)return{do:"f",row:e};break;case"<":if(this.setCodeLock)return{do:"l-"};if(r)return{do:"l+",setCode:r.set,usePrev:!0};break;case"x":if(e)return{do:"x",row:e};break;case"?":return{do:"?"}}if(t.slice(0,1)==="<"&&this.setByCode(t.slice(1)))return{do:"l+",setCode:t.slice(1)};const a=this.matchCardRef(t);if(a){const{card:c,foil:i,usePrev:l}=a;return{do:"+",match:{card:c,foil:i},usePrev:l}}return this.setCodeLock?{do:"s",search:`${t} set:${this.setCodeLock}`}:{do:"s",search:t}},get actionLabel(){switch(this.action.do){case null:case"s":return"Search Card";case"+":return"Add Card";case"++":return"Add Another";case"vC":return"View Card";case"vR":return"View Results";case"f":return"Toggle Foil";case"l+":return"Lock Set: "+this.action.setCode;case"l-":return"Unlock Set";case"x":return"Remove Row";case"?":return"Open Help"}},padCardNum(e){const r=this.setByCode(e.set),t=e.num+"";return r?t.padStart((r.card_count+"").length,"0"):t},mainAction(e){const r=this.action;switch(r.do){case null:return;case"+":this.fetchCard(r.match.card,r.match.foil).then();break;case"s":this.searchCard(r.search).then();break;case"++":this.addAnother(r.row).then();break;case"vC":e("view-card",r.row.card.card);break;case"vR":e("view-results",r.row);break;case"f":this.updateRow(r.row,{foil:!r.row.foil}).then();break;case"l+":this.setCodeLock=r.setCode;break;case"l-":this.setCodeLock=null;break;case"x":this.list.remove(r.row).then();break;case"?":e("open-help");break}this.resetInputs(),e("reset-set-search")},async fetchCard(e,r){const t=await this.list.add({card:e,foil:r});let a=t.card.card;a||(a=await d.cards.recall(t.card));const s=1e3*60*60*24*7;if(!a||a.savedAt<Date.now()-s)try{a=this.prepareScryfallCard(await this.scryfall(`cards/${e.set}/${e.num}`)),await d.cards.set(a)}catch(n){console.log("Error fetching and/or storing card",{ref:e,result:a||null,row:t}),t.error=n,console.error(n),await this.list.removeRowRecord(t)}},async searchCard(e){const r=await this.list.add({search:{q:e}}),t=new URLSearchParams;t.set("q",e),t.set("unique","prints"),t.set("order","released");try{let a=await this.scryfall(`cards/search?${t.toString()}`);a=await Promise.all(a.data.map(s=>(s=this.prepareScryfallCard(s),d.cards.set(s).then(()=>d.cardPop(s))))),a.length===1?(console.log("updating row with single result",a),await this.updateRow(r,{card:a[0]})):(console.log("updating row with results list",a),await this.updateRow(r,{results:a}))}catch(a){r.error=a,console.error(r),await this.list.removeRowRecord(r)}},addAnother(e){const{search:r=null,card:t=null,foil:a}=e;return this.list.add({search:r,card:t,foil:a})},async updateRow(e,{card:r=null,results:t=null,foil:a=null}){r?(e.card=r,e.search=void 0):t&&(e.search.results=t),a!==null&&(e.foil=a),await this.list.update(e)},async removeRow(e){await this.list.remove(e)},async clearList(){window.confirm("Are you sure you want to remove all cards from the list?")&&await this.list.clear()},resetInputs(){this.search="",this.rowActionIndex=0,this.placeholder=o()},async scryfall(...e){const r=await u(...e);if(!r.ok)throw new Error(`Response status: ${r.status}`);return await r.json()},prepareScryfallCard(e){var m,w;const{name:r,set:t,collector_number:a,finishes:s,image_status:n,image_uris:c=null,card_faces:i=[]}=e,l=(c==null?void 0:c.png)||((w=(m=i[0])==null?void 0:m.image_uris)==null?void 0:w.png)||null;return{name:r,set:t,num:a,finishes:s,imageStatus:n,imageUri:l,fetchedAt:Date.now()}}}))});
