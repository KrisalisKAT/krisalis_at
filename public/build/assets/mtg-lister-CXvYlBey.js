function m(o){return new Promise((d,u)=>{o.onsuccess=e=>{d(e.target.result)},o.onerror=e=>{console.error(e),u(e.target.error||e)}})}async function L(o,d,u){const e=await new Promise(r=>{const t=window.indexedDB.open(o,d);t.onsuccess=a=>{r(a.target.result)},t.onupgradeneeded=a=>{const s=a.target.result;s.onerror=n=>{var c;console.error((c=n.target.error)==null?void 0:c.message)},u(s)}});return e.onerror=r=>{var t;console.error((t=r.target.error)==null?void 0:t.message)},e}function g(o){const{set:d,num:u}=o;return`${d} ${u}`}function C(o){const{set:d,num:u}=o;return{set:d,num:u}}function b(){const o=L("mtg-lister",1,t=>{t.createObjectStore("cards",{keyPath:"setNum"}),t.createObjectStore("cardList",{autoIncrement:!0}).createIndex("listName","listName",{unique:!1}),t.createObjectStore("options",{keyPath:"name"})}),d={async save(t){await this.saveAll([t])},async saveAll(t){t.forEach(s=>{s.setNum=s.setNum||g(s),s.savedAt=Date.now()});const a=(await o).transaction(["cards"],"readwrite").objectStore("cards");for(let s=0;s<t.length;s++)try{await a.put(t[s])}catch(n){console.log("Error storing card to DB",{card:t[s],cards:t}),console.error(n)}},async get(t){try{return m((await o).transaction(["cards"]).objectStore("cards").get(g(t)))}catch{return null}},async getList(t){const a=Object.keys(t.map(i=>g(i)).reduce((i,l)=>(i[l]=null,i),{})),s=[],n=(await o).transaction(["cards"]).objectStore("cards");let c;for(let i=0;i<t.length;i++)try{c=await m(n.get(a[i])),c?s.push(c):console.log("card not found",a[i])}catch(l){console.log("Error retrieving card "+a[i]),console.error(l)}return s}};function u(t){var i;const{key:a=null,listName:s=null,search:n=null,foil:c=!1}=t;return{key:a||void 0,listName:s===null?void 0:s,search:n?{q:n.q,results:(i=n.results)==null?void 0:i.map(C)}:void 0,card:t.card?C(t.card):null,foil:c}}return{cards:d,lists:{async getLists(){const t=await o,a=[];return await new Promise(s=>{const c=t.transaction(["cardList"]).objectStore("cardList").index("listName");c.openKeyCursor(null,"nextunique").onsuccess=i=>{const l=i.target.result;l?(a.push(l.key),l.continue()):s()}}),a},async getList(t=""){return m((await o).transaction(["cardList"]).objectStore("cardList").getAll())},async addRow(t,a=""){try{t=u(t),t.listName=a;const s=(await o).transaction(["cardList"],"readwrite").objectStore("cardList");return t.key=await m(s.add(t)),await m(s.put(t,t.key)),t}catch(s){console.log("Error adding row"),console.error(s)}},async updateRow(t){try{t=u(t);const a=(await o).transaction(["cardList"],"readwrite").objectStore("cardList");await m(a.put(t,t.key))}catch(a){console.log("error updating row"),console.error(a)}},async removeRow(t){console.error("removing row",t),await m((await o).transaction(["cardList"],"readwrite").objectStore("cardList").delete(t))},async clearList(t=""){const a=await o;return new Promise(s=>{const c=a.transaction(["cardList"],"readwrite").objectStore("cardList").index("listName");c.openCursor(IDBKeyRange.only(t)).onsuccess=i=>{const l=i.target.result;l?(l.delete(),l.continue()):s()}})}},options:{async get(t,a=null){const s=await m((await o).transaction(["options"]).objectStore("options").get(t));return(s==null?void 0:s.value)||a},async set(t,a){await m((await o).transaction(["options"],"readwrite").objectStore("options").put({name:t,value:a}))}}}}function v(){const o=b(),d=Alpine.reactive({}),u={get(s){return d[g(s)]||null},set(s){return o.cards.save(this.remember(s))},setList(s){return s.forEach(n=>this.remember(n)),o.cards.saveAll(s)},remember(s){return s&&(d[g(s)]=s),s},async recall(s){return(await this.recallList([s]))[0]},async recallList(s){const n=await o.cards.getList(s.filter(c=>!this.get(c)));return n.forEach(c=>this.remember(c)),n}};async function e(){return o.lists.getLists()}function r(s){const{set:n,num:c}=s;return{set:n,num:c,get card(){return u.get(s)}}}function t(s){var n;return{...s,search:s.search?{q:s.search.q,results:(n=s.search.results)==null?void 0:n.map(r)}:void 0,card:s.card?r(s.card):null,error:null,loading:!1,get hasError(){return!!this.error},async setCard(c){this.card=r(c),this.search&&(this.search=null),await o.lists.updateRow(s)},async toggleFoil(){this.foil=!this.foil,await o.lists.updateRow(s)},async setSearchResults(c){this.search.results=c.map(r),await o.lists.updateRow(s)}}}function a(s){return{rows:[],async add(n){const c=await o.lists.addRow(n,s),i=t(c),l=this.rows.push(i);return this.rows[l-1]},async remove(n){return this.rows.splice(this.rows.indexOf(n),1),this.removeRowRecord(n)},async removeRowRecord(n){return o.lists.removeRow(n.key)},async clear(){this.rows=[],await o.lists.clearList(s)},async update(n){await o.lists.updateRow(n)},get byNew(){return this.rows.toReversed()},async populate(){const c=(await o.lists.getList(s)).map(h=>t(h)),i=this.rows.length;this.rows.push(...c);const l={};c.forEach(h=>{h.card?l[g(h.card)]=h.card:h.search&&(h.search.results?h.search.results.forEach(f=>{l[g(f)]=f}):h.error="Search incomplete")}),await u.recallList(Object.values(l));for(let h=i;h<this.rows.length;h++){let f=this.rows[h];f.card&&!f.card.card&&(f.error="Card unknown",console.log("Unknown card in list",{cardRef:r(f.card),row:f}))}}}}return{cards:u,cardPop:r,getLists:e,list:a}}document.addEventListener("alpine:init",()=>{const o=()=>(e=>e[Math.floor(Math.random()*e.length)])(["eld 299","fdn 128","snc 425","woe 287","ncc 13"]),d=v(),u=kat.rateLimitedService("https://api.scryfall.com/",100);Alpine.data("mtgLister",()=>({search:"",cardData:d.cards,isFoil:!1,list:d.list(""),lists:[],placeholder:o(),preview:null,select:null,hasSetsData:!!mtgSets.length,rowActionIndex:0,setCodeLock:null,async init(){this.lists=await d.getLists(),await this.list.populate()},get actionRow(){return this.list.byNew[this.rowActionIndex]||null},get setCodeHint(){var e;if(this.action.usePrev){if(this.action.do==="+")return this.action.match.card.set.toUpperCase();if(this.action.do==="l+")return this.action.setCode.toUpperCase()}return(e=this.setCodeLock)==null?void 0:e.toUpperCase()},setByCode(e){if(this.hasSetsData)try{return mtgSets.find(r=>r.code===e.toLowerCase())||null}catch(r){return console.error(e,r),null}return null},get lockedSetPlaceholder(){return this.setCodeLock?String(Math.floor(Math.random()*this.lockedSet.card_count)+1):this.placeholder},get lockedSet(){return this.setCodeLock?this.setByCode(this.setCodeLock):null},setName(e){const r=this.setByCode(e);return r?r.name:e.toUpperCase()},get resolvedCards(){return this.list.rows.filter(r=>{var t;return(t=r.card)==null?void 0:t.card})},get distinctCards(){const e=this.resolvedCards,r={},t=[];return e.forEach(a=>{const s=`${a.card.set}:${a.card.num}:${a.foil?"foil":"-"}`;r[s]!==void 0?t[r[s]].count++:(r[s]=t.length,t.push({count:1,name:a.card.card.name,set:a.card.set,num:a.card.num,foil:a.foil}))}),t},get csvDownload(){return encodeURI(`data:text/csv;charset=utf-8,Count,Name,Edition,Collector Number,Foil\r
`+this.distinctCards.map(e=>[e.count,`"${e.name.replace('"','""')}"`,e.set,e.num,e.foil?"foil":""].join(",")).join(`\r
`))},get csvFileName(){const e=this.resolvedCards.length;if(!e)return"mtg-list_empty.csv";const r=this.distinctCards[0].name.replace(/[^a-z0-9]/gi,"_").toLowerCase();return`mtg-list_${e}_${r}.csv`},matchCardRef(e){var c,i;if(!this.hasSetsData)return null;const r=e.split(" ");if(r.length===1&&this.setCodeLock&&r.unshift(this.setCodeLock),r.length!==2)return null;const t=r[0]==="<";if(t)if((i=(c=this.actionRow)==null?void 0:c.card)!=null&&i.set)r[0]=this.actionRow.card.set;else return null;const a=this.setByCode(r[0]);if(!a)return null;const s=r[1].match(/(?<number>\d{1,4})(?<foil>f?)/i);if(!s)return null;const n=Number(s.groups.number);return n>a.card_count?null:{card:{set:a.code,num:n},foil:!!s.groups.foil,usePrev:t}},get action(){var s,n;const e=this.actionRow,r=(s=e==null?void 0:e.card)==null?void 0:s.card,t=this.search.trim().toLowerCase();if(!t){if(!e)return{do:null};if(r||(n=e.search)!=null&&n.results)return{do:"++",row:e};if(e.error){if(e.card)return{do:"üîÅ",row:e};if(e.search)return{do:"‚úèÔ∏è",search:e.search.q,row:e}}}if(t.length===1)switch(t){case"v":if(e)return{do:r?"vC":"vR",row:e};break;case"f":if(r)return{do:"f",row:e};break;case"<":if(this.setCodeLock)return{do:"l-"};if(r)return{do:"l+",setCode:r.set,usePrev:!0};break;case"x":if(e)return{do:"x",row:e};break;case"?":return{do:"?"}}if(t.slice(0,1)==="<"&&this.setByCode(t.slice(1)))return{do:"l+",setCode:t.slice(1)};const a=this.matchCardRef(t);if(a){const{card:c,foil:i,usePrev:l}=a;return{do:"+",match:{card:c,foil:i},usePrev:l}}return this.setCodeLock?{do:"s",search:`${t} set:${this.setCodeLock}`}:{do:"s",search:t}},get actionLabel(){switch(this.action.do){case null:case"s":return"Search Card";case"+":return"Add Card";case"üîÅ":return"Retry Fetch";case"‚úèÔ∏è":return"Edit Search";case"++":return"Add Another";case"vC":return"View Card";case"vR":return"View Results";case"f":return"Toggle Foil";case"l+":return"Lock Set: "+this.action.setCode;case"l-":return"Unlock Set";case"x":return"Remove Row";case"?":return"Open Help"}},padCardNum(e){const r=this.setByCode(e.set),t=e.num+"";return r?t.padStart((r.card_count+"").length,"0"):t},mainAction(e){const r=this.action;if(r.do!==null)switch(this.resetInputs(),e("reset-set-search"),r.do){case"+":return this.fetchCard(r.match.card,r.match.foil);case"s":return this.searchCard(r.search);case"üîÅ":return this.retryFetchCard(r.row);case"‚úèÔ∏è":return this.search=r.search,this.removeRow(r.row);case"++":return this.addAnother(r.row);case"vC":e("view-card",r.row.card.card);return;case"vR":e("view-results",r.row),console.log("view-results");return;case"f":return r.row.toggleFoil();case"l+":this.setCodeLock=r.setCode;return;case"l-":this.setCodeLock=null;return;case"x":return this.list.remove(r.row);case"?":e("open-help");return}},async fetchCard(e,r){const t=await this.list.add({card:e,foil:r});let a=t.card.card;a||(a=await d.cards.recall(t.card));const s=1740248073222,n=Date.now()-1e3*60*60*24*7;(!a||a.fetchedAt<Math.max(s,n))&&await this.fetchAndStoreCard(t)},async fetchAndStoreCard(e){const r=e.card;let t=null;try{e.loading=!0,t=this.prepareScryfallCard(await this.scryfall(`cards/${r.set}/${r.num}`))}catch(a){e.error=a.message==="404"?"Card not found":a.message,console.log("Error fetching and/or storing card",{ref:r,result:t||null,row:e}),console.error(a)}e.loading=!1,t&&await d.cards.set(t)},async retryFetchCard(e){e.error=null,await this.fetchAndStoreCard(e)},async searchCard(e){const r=await this.list.add({search:{q:e}}),t=new URLSearchParams;t.set("q",e),t.set("unique","prints"),t.set("order","released");let a;r.loading=!0;try{a=await this.scryfall(`cards/search?${t.toString()}`)}catch(n){r.error=n.message==="404"?"No results":n.message,console.log("Error searching card",{results:a},r),console.error(n)}if(r.loading=!1,!a)return;const s=a.data.map(n=>this.prepareScryfallCard(n));await d.cards.setList(s),a.length===1?await r.setCard(s[0]):await r.setSearchResults(s)},setActionRow(e){this.rowActionIndex=Math.max(Math.min(e,this.list.rows.length-1),0),document.getElementById("cardsList").children[this.rowActionIndex].scrollIntoView({block:"center",behavior:"smooth"})},addAnother(e){const{search:r=null,card:t=null,foil:a}=e;return this.list.add({search:r,card:t,foil:a})},async updateRow(e,{card:r=null,results:t=null,foil:a=null}){r?(e.card=r,e.search=void 0):t&&(e.search.results=t),a!==null&&(e.foil=a),await this.list.update(e)},async removeRow(e){await this.list.remove(e)},async clearList(){window.confirm("Are you sure you want to remove all cards from the list?")&&await this.list.clear()},resetInputs(){this.search="",this.rowActionIndex=0,this.placeholder=o()},async scryfall(...e){const r=await u(...e);if(!r.ok)throw console.error({response:r,body:await r.json().catch()}),new Error(r.status===404?"404":`Response status: ${r.status}`);return await r.json()},prepareScryfallCard(e){var f,w,p,y;const{name:r,set:t,collector_number:a,finishes:s,image_status:n,image_uris:c=null,card_faces:i=[]}=e,l=(c==null?void 0:c.png)||((w=(f=i[0])==null?void 0:f.image_uris)==null?void 0:w.png)||null,h=((y=(p=i[1])==null?void 0:p.image_uris)==null?void 0:y.png)||null;return{name:r,set:t,num:a,finishes:s,imageStatus:n,imageUri:l,backFaceUri:h,fetchedAt:Date.now()}}}))});
