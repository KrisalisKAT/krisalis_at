function h(o){return new Promise((d,u)=>{o.onsuccess=s=>{d(s.target.result)},o.onerror=s=>{console.error(s),u(s.target.error||s)}})}async function p(o,d,u){const s=await new Promise(r=>{const t=window.indexedDB.open(o,d);t.onsuccess=a=>{r(a.target.result)},t.onupgradeneeded=a=>{const e=a.target.result;e.onerror=n=>{var c;console.error((c=n.target.error)==null?void 0:c.message)},u(e)}});return s.onerror=r=>{var t;console.error((t=r.target.error)==null?void 0:t.message)},s}function f(o){const{set:d,num:u}=o;return`${d} ${u}`}function g(o){const{set:d,num:u}=o;return{set:d,num:u}}function y(){const o=p("mtg-lister",1,t=>{t.createObjectStore("cards",{keyPath:"setNum"}),t.createObjectStore("cardList",{autoIncrement:!0}).createIndex("listName","listName",{unique:!1}),t.createObjectStore("options",{keyPath:"name"})}),d={async save(t){await this.saveAll([t])},async saveAll(t){t.forEach(e=>{e.setNum=e.setNum||f(e),e.savedAt=Date.now()});const a=(await o).transaction(["cards"],"readwrite").objectStore("cards");for(let e=0;e<t.length;e++)try{await a.put(t[e])}catch(n){console.log("Error storing card to DB",{card:t[e],cards:t}),console.error(n)}},async get(t){try{return h((await o).transaction(["cards"]).objectStore("cards").get(f(t)))}catch{return null}},async getList(t){const a=Object.keys(t.map(i=>f(i)).reduce((i,l)=>(i[l]=null,i),{})),e=[],n=(await o).transaction(["cards"]).objectStore("cards");let c;for(let i=0;i<t.length;i++)try{c=await h(n.get(a[i])),c?e.push(c):console.log("card not found",a[i])}catch(l){console.log("Error retrieving card "+a[i]),console.error(l)}return e}};function u(t){var i;const{key:a=null,listName:e=null,search:n=null,foil:c=!1}=t;return{key:a||void 0,listName:e===null?void 0:e,search:n?{q:n.q,results:(i=n.results)==null?void 0:i.map(g)}:void 0,card:t.card?g(t.card):null,foil:c}}return{cards:d,lists:{async getLists(){const t=await o,a=[];return await new Promise(e=>{const c=t.transaction(["cardList"]).objectStore("cardList").index("listName");c.openKeyCursor(null,"nextunique").onsuccess=i=>{const l=i.target.result;l?(a.push(l.key),l.continue()):e()}}),a},async getList(t=""){return h((await o).transaction(["cardList"]).objectStore("cardList").getAll())},async addRow(t,a=""){try{t=u(t),t.listName=a;const e=(await o).transaction(["cardList"],"readwrite").objectStore("cardList");return t.key=await h(e.add(t)),await h(e.put(t,t.key)),t}catch(e){console.log("Error adding row"),console.error(e)}},async updateRow(t){try{t=u(t);const a=(await o).transaction(["cardList"],"readwrite").objectStore("cardList");await h(a.put(t,t.key))}catch(a){console.log("error updating row"),console.error(a)}},async removeRow(t){console.error("removing row",t),await h((await o).transaction(["cardList"],"readwrite").objectStore("cardList").delete(t))},async clearList(t=""){const a=await o;return new Promise(e=>{const c=a.transaction(["cardList"],"readwrite").objectStore("cardList").index("listName");c.openCursor(IDBKeyRange.only(t)).onsuccess=i=>{const l=i.target.result;l?(l.delete(),l.continue()):e()}})}},options:{async get(t,a=null){const e=await h((await o).transaction(["options"]).objectStore("options").get(t));return(e==null?void 0:e.value)||a},async set(t,a){await h((await o).transaction(["options"],"readwrite").objectStore("options").put({name:t,value:a}))}}}}function C(){const o=y(),d=Alpine.reactive({}),u={get(e){return d[f(e)]||null},set(e){return o.cards.save(this.remember(e))},setList(e){return e.forEach(n=>this.remember(n)),o.cards.saveAll(e)},remember(e){return e&&(d[f(e)]=e),e},async recall(e){let n=this.get(e);return n||(n=await o.cards.get(e),n&&console.info("card recalled",n),this.remember(n))},async recallList(e){(await o.cards.getList(e.filter(c=>!this.get(c)))).forEach(c=>this.remember(c))}};async function s(){return o.lists.getLists()}function r(e){const{set:n,num:c}=e;return{set:n,num:c,get card(){return u.get(e)}}}function t(e){var n;return{...e,search:e.search?{q:e.search.q,results:(n=e.search.results)==null?void 0:n.map(r)}:void 0,card:e.card?r(e.card):null,error:null,get hasError(){return!!this.error}}}function a(e){return{rows:[],async add(n){const c=await o.lists.addRow(n,e),i=t(c),l=this.rows.push(i);return this.rows[l-1]},async remove(n){return this.rows.splice(this.rows.indexOf(n),1),this.removeRowRecord(n)},async removeRowRecord(n){return o.lists.removeRow(n.key)},async clear(){this.rows=[],await o.lists.clearList(e)},async update(n){await o.lists.updateRow(n)},get byNew(){return this.rows.toReversed()},async populate(){const c=(await o.lists.getList(e)).map(l=>t(l));this.rows.push(...c);const i={};c.forEach(l=>{var m;l.card?i[f(l.card)]=l.card:(m=l.search)!=null&&m.results&&l.search.results.forEach(w=>{i[f(w)]=w})}),await u.recallList(Object.values(i))}}}return{cards:u,cardPop:r,getLists:s,list:a}}document.addEventListener("alpine:init",()=>{const o=()=>(s=>s[Math.floor(Math.random()*s.length)])(["eld 299","fdn 128","snc 425","woe 287","ncc 13"]),d=C(),u=kat.rateLimitedService("https://api.scryfall.com/",100);Alpine.data("mtgLister",()=>({search:"",cardData:d.cards,isFoil:!1,list:d.list(""),lists:[],placeholder:o(),preview:null,select:null,hasSetsData:!!mtgSets.length,rowActionIndex:0,setCodeLock:null,async init(){this.lists=await d.getLists(),await this.list.populate()},get actionRow(){return this.list.byNew[this.rowActionIndex]||null},get setCodeHint(){var s;if(this.action.usePrev){if(this.action.do==="+")return this.action.match.card.set.toUpperCase();if(this.action.do==="l+")return this.action.setCode.toUpperCase()}return(s=this.setCodeLock)==null?void 0:s.toUpperCase()},setByCode(s){if(this.hasSetsData)try{return mtgSets.find(r=>r.code===s.toLowerCase())||null}catch(r){return console.error(s,r),null}return null},get lockedSetPlaceholder(){return this.setCodeLock?String(Math.floor(Math.random()*this.lockedSet.card_count)+1):this.placeholder},get lockedSet(){return this.setCodeLock?this.setByCode(this.setCodeLock):null},setName(s){const r=this.setByCode(s);return r?r.name:s.toUpperCase()},get resolvedCards(){return this.list.rows.filter(r=>{var t;return(t=r.card)==null?void 0:t.card})},get distinctCards(){const s=this.resolvedCards,r={},t=[];return s.forEach(a=>{const e=`${a.card.set}:${a.card.num}:${a.foil?"foil":"-"}`;r[e]!==void 0?t[r[e]].count++:(r[e]=t.length,t.push({count:1,name:a.card.card.name,set:a.card.set,num:a.card.num,foil:a.foil}))}),t},get csvDownload(){return encodeURI(`data:text/csv;charset=utf-8,Count,Name,Edition,Collector Number,Foil\r
`+this.distinctCards.map(s=>[s.count,`"${s.name.replace('"','""')}"`,s.set,s.num,s.foil?"foil":""].join(",")).join(`\r
`))},get csvFileName(){const s=this.resolvedCards.length;if(!s)return"mtg-list_empty.csv";const r=this.distinctCards[0].name.replace(/[^a-z0-9]/gi,"_").toLowerCase();return`mtg-list_${s}_${r}.csv`},matchCardRef(s){var c,i;if(!this.hasSetsData)return null;const r=s.split(" ");if(r.length===1&&this.setCodeLock&&r.unshift(this.setCodeLock),r.length!==2)return null;const t=r[0]==="<";if(t)if((c=this.actionRow)!=null&&c.set)r[0]=this.actionRow.set;else return null;const a=this.setByCode(r[0]==="<"&&((i=this.actionRow)!=null&&i.set)?this.actionRow.set:r[0]);if(!a)return null;const e=r[1].match(/(?<number>\d{1,4})(?<foil>f?)/i);if(!e)return null;const n=Number(e.groups.number);return n>a.card_count?null:{card:{set:a.code,num:n},foil:!!e.groups.foil,usePrev:t}},get action(){var e,n;const s=this.actionRow,r=(e=s==null?void 0:s.card)==null?void 0:e.card,t=this.search.trim().toLowerCase();if(!t)return r||(n=s==null?void 0:s.search)!=null&&n.results?{do:"++",row:s}:{do:null};if(t.length===1)switch(t){case"v":if(s)return{do:r?"vC":"vR",row:s};break;case"f":if(r)return{do:"f",row:s};break;case"<":if(this.setCodeLock)return{do:"l-"};if(r)return{do:"l+",setCode:r.set,usePrev:!0};break;case"x":if(s)return{do:"x",row:s};break;case"?":return{do:"?"}}if(t.slice(0,1)==="<"&&this.setByCode(t.slice(1)))return{do:"l+",setCode:t.slice(1)};const a=this.matchCardRef(t);if(a){const{card:c,foil:i,usePrev:l}=a;return{do:"+",match:{card:c,foil:i},usePrev:l}}return this.setCodeLock?{do:"s",search:`${t} set:${this.setCodeLock}`}:{do:"s",search:t}},get actionLabel(){switch(this.action.do){case null:case"s":return"Search Card";case"+":return"Add Card";case"++":return"Add Another";case"vC":return"View Card";case"vR":return"View Results";case"f":return"Toggle Foil";case"l+":return"Lock Set: "+this.action.setCode;case"l-":return"Unlock Set";case"x":return"Remove Row";case"?":return"Open Help"}},padCardNum(s){const r=this.setByCode(s.set),t=s.num+"";return r?t.padStart((r.card_count+"").length,"0"):t},mainAction(s){const r=this.action;switch(r.do){case null:return;case"+":this.fetchCard(r.match.card,r.match.foil).then();break;case"s":this.searchCard(r.search).then();break;case"++":this.addAnother(r.row).then();break;case"vC":s("view-card",r.row.card.card);break;case"vR":s("view-results",r.row);break;case"f":this.updateRow(r.row,{foil:!r.row.foil}).then();break;case"l+":this.setCodeLock=r.setCode;break;case"l-":this.setCodeLock=null;break;case"x":this.list.remove(r.row).then();break;case"?":s("open-help");break}this.resetInputs(),s("reset-set-search")},async fetchCard(s,r){const t=await this.list.add({card:s,foil:r});let a=t.card.card;a||(a=await d.cards.recall(t.card));const e=1e3*60*60*24*7;if(!a||a.savedAt<Date.now()-e)try{a=this.prepareScryfallCard(await this.scryfall(`cards/${s.set}/${s.num}`)),await d.cards.set(a)}catch(n){console.log("Error fetching and/or storing card",{ref:s,result:a||null,row:t}),t.error=n,console.error(n),await this.list.removeRowRecord(t)}},async searchCard(s){const r=await this.list.add({search:{q:s}}),t=new URLSearchParams;t.set("q",s),t.set("unique","prints"),t.set("order","released");try{let a=await this.scryfall(`cards/search?${t.toString()}`);a=await Promise.all(a.data.map(e=>(e=this.prepareScryfallCard(e),d.cards.set(e).then(()=>d.cardPop(e))))),a.length===1?(console.log("updating row with single result",a),await this.updateRow(r,{card:a[0]})):(console.log("updating row with results list",a),await this.updateRow(r,{results:a}))}catch(a){r.error=a,console.error(r),await this.list.removeRowRecord(r)}},addAnother(s){const{search:r=null,card:t=null,foil:a}=s;return this.list.add({search:r,card:t,foil:a})},async updateRow(s,{card:r=null,results:t=null,foil:a=null}){r?(s.card=r,s.search=void 0):t&&(s.search.results=t),a!==null&&(s.foil=a),await this.list.update(s)},async removeRow(s){await this.list.remove(s)},async clearList(){window.confirm("Are you sure you want to remove all cards from the list?")&&await this.list.clear()},resetInputs(){this.search="",this.rowActionIndex=0,this.placeholder=o()},async scryfall(...s){const r=await u(...s);if(!r.ok)throw new Error(`Response status: ${r.status}`);return await r.json()},prepareScryfallCard(s){var m,w;const{name:r,set:t,collector_number:a,finishes:e,image_status:n,image_uris:c=null,card_faces:i=[]}=s,l=(c==null?void 0:c.png)||((w=(m=i[0])==null?void 0:m.image_uris)==null?void 0:w.png)||null;return{name:r,set:t,num:a,finishes:e,imageStatus:n,imageUri:l,fetchedAt:Date.now()}}}))});
